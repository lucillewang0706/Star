<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Merry Christmas & Happy New Year</title>
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- Import Map: Pinned React 18.2.0 Stack & Three 0.160.0 -->
  <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
        "three": "https://esm.sh/three@0.160.0",
        "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.16?external=react,react-dom,three",
        "@react-three/drei": "https://esm.sh/@react-three/drei@9.99.0?external=react,react-dom,three,@react-three/fiber",
        "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0?external=react,react-dom,three,@react-three/fiber",
        "postprocessing": "https://esm.sh/postprocessing@6.34.1?external=three",
        "uuid": "https://esm.sh/uuid@9.0.1",
        "@mediapipe/tasks-vision": "https://esm.sh/@mediapipe/tasks-vision@0.10.8"
      }
    }
  </script>

  <!-- Babel -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #000010; }
    #root { width: 100%; height: 100%; }
    
    @keyframes pulse-glow {
      0%, 100% { text-shadow: 0 0 20px #FFD700, 0 0 40px #FFA500; transform: scale(1); }
      50% { text-shadow: 0 0 40px #FFD700, 0 0 80px #FFA500; transform: scale(1.1); }
    }
    .countdown-text {
      font-family: 'Times New Roman', serif;
      animation: pulse-glow 1s infinite ease-in-out;
    }
    .loading-text {
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    /* Hide scrollbar for planet facts overlay */
    .no-scrollbar::-webkit-scrollbar {
      display: none;
    }
    .no-scrollbar {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }

    /* Webcam Container */
    #webcam-container {
      position: absolute;
      top: 80px;
      right: 24px;
      width: 160px;
      height: 120px;
      border-radius: 12px;
      overflow: hidden;
      border: 2px solid rgba(255, 255, 255, 0.3);
      z-index: 40;
      display: none; /* Hidden by default (I-Mode) */
      transform: scaleX(-1); /* Mirror effect */
    }
    video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    /* Floating Emoji Animation */
    @keyframes floatUp {
      0% { transform: translateY(100vh) scale(0.5); opacity: 0; }
      10% { opacity: 1; }
      100% { transform: translateY(-20vh) scale(1.5); opacity: 0; }
    }
    .emoji-particle {
      position: absolute;
      font-size: 2rem;
      pointer-events: none;
      animation: floatUp 3s linear forwards;
      z-index: 60;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- Audio Element for Dynamic Music -->
  <audio id="bg-music" loop preload="auto" crossorigin="anonymous"></audio>

  <!-- Meteor Sound Effect -->
  <audio id="meteor-fx">
    <source src="https://cdn.pixabay.com/download/audio/2022/03/24/audio_338a906253.mp3?filename=magic-chime-02-6014.mp3" type="audio/mpeg">
  </audio>

  <script type="text/babel" data-type="module">
    import React, { useState, useRef, useMemo, useEffect, Suspense } from 'react';
    import { createRoot } from 'react-dom/client';
    import * as THREE from 'three';
    import { Canvas, useFrame, useThree } from '@react-three/fiber';
    import { OrbitControls, PerspectiveCamera, Stars, Float, Text3D, Center, Sparkles, Html } from '@react-three/drei';
    import { EffectComposer, Bloom, Vignette } from '@react-three/postprocessing';
    import { GestureRecognizer, FaceLandmarker, FilesetResolver, DrawingUtils } from '@mediapipe/tasks-vision';

    // --- Constants ---
    const COUNT = 2000;
    const SHAPES = {
      SCATTERED: 'SCATTERED',
      TREE: 'TREE',
      HEART: 'HEART'
    };
    
    // --- Songs Configuration (Remote URLs) ---
    const SONGS = {
      TREE: "https://raw.githubusercontent.com/lucillewang0706/Music/cdbb3a2d4451e3aa39f21caa494030cf45c76058/All_I_Want_for_Christmas_Is_You.mp3",
      HEART_GALAXY: "https://raw.githubusercontent.com/lucillewang0706/Music/cdbb3a2d4451e3aa39f21caa494030cf45c76058/Cornfield_Chase.mp3",
      WISH: "https://raw.githubusercontent.com/lucillewang0706/Music/cdbb3a2d4451e3aa39f21caa494030cf45c76058/Dreamers.mp3"
    };

    // --- Helper Functions ---
    const randomRange = (min, max) => Math.random() * (max - min) + min;

    // --- Components ---

    // 1. Loading Screen
    const Loader = () => {
      return (
        <Html center>
          <div className="text-yellow-200 font-serif text-xl tracking-widest loading-text whitespace-nowrap">
            Loading Christmas Magic...
          </div>
        </Html>
      );
    };

    // 2. Magic Particles (The Tree/Heart Body)
    const MagicParticles = ({ shape }) => {
      const meshRef = useRef();
      const { viewport } = useThree();
      
      const dummy = useMemo(() => new THREE.Object3D(), []);
      
      const particles = useMemo(() => {
        const temp = [];
        // Tree Points (Spiral Cone)
        const treePoints = [];
        for (let i = 0; i < COUNT; i++) {
          const y = randomRange(-4, 4);
          const radius = (4 - y) * 0.4;
          const angle = y * 5 + Math.random() * Math.PI * 2;
          treePoints.push(new THREE.Vector3(Math.cos(angle) * radius, y, Math.sin(angle) * radius));
        }

        // Heart Points (Fully Filled Volume)
        const heartPoints = [];
        
        // Use a simpler, guaranteed volume fill: Random point in sphere -> scale to heart
        let safety = 0;
        while(heartPoints.length < COUNT && safety < 50000) {
          safety++;
          const rx = randomRange(-1.5, 1.5);
          const ry = randomRange(-1.5, 2.0);
          const rz = randomRange(-1.5, 1.5);
          
          const nx = rx;
          const ny = ry - 0.4;
          const nz = rz;
          
          const a = nx*nx + (9/4)*ny*ny + nz*nz - 1;
          const term2 = nx*nx * nz*nz*nz;
          const term3 = (9/80)*ny*ny * nz*nz*nz;
          
          if (a*a*a - term2 - term3 <= 0) {
             const scale = 2.0; 
             heartPoints.push(new THREE.Vector3(rx * scale, ry * scale, rz * scale));
          }
        }
        
        // Fallback if loop timed out
        while(heartPoints.length < COUNT) {
             heartPoints.push(new THREE.Vector3(0,0,0));
        }

        // Scattered Points (Cloud)
        const scatteredPoints = [];
        for (let i = 0; i < COUNT; i++) {
          scatteredPoints.push(new THREE.Vector3(randomRange(-8, 8), randomRange(-5, 8), randomRange(-5, 5)));
        }

        for (let i = 0; i < COUNT; i++) {
          temp.push({
            tree: treePoints[i],
            heart: heartPoints[i] || new THREE.Vector3(0,0,0),
            scattered: scatteredPoints[i],
            current: scatteredPoints[i].clone(),
            speed: randomRange(0.02, 0.05),
            offset: Math.random() * 100
          });
        }
        return temp;
      }, []);

      useFrame((state) => {
        if (!meshRef.current) return;
        
        const time = state.clock.getElapsedTime();

        particles.forEach((particle, i) => {
          let target;
          if (shape === SHAPES.TREE) target = particle.tree;
          else if (shape === SHAPES.HEART) target = particle.heart;
          else target = particle.scattered;

          // Morphing
          particle.current.lerp(target, 0.03);

          // Breathing
          const breathe = Math.sin(time * 2 + particle.offset) * 0.05;
          
          dummy.position.set(
            particle.current.x,
            particle.current.y + breathe,
            particle.current.z
          );
          
          const scale = (Math.sin(time * 3 + particle.offset) * 0.2 + 0.8) * 0.15;
          dummy.scale.set(scale, scale, scale);
          dummy.rotation.set(time * 0.2, time * 0.1, 0);
          dummy.updateMatrix();
          meshRef.current.setMatrixAt(i, dummy.matrix);
        });
        
        meshRef.current.instanceMatrix.needsUpdate = true;
      });

      return (
        <instancedMesh ref={meshRef} args={[null, null, COUNT]}>
          <dodecahedronGeometry args={[0.2, 0]} />
          {/* Silver-Green Shimmer (Dimmed) */}
          <meshStandardMaterial 
            color="#2E8B57"        
            emissive="#B0E0E6"     
            emissiveIntensity={0.15} 
            roughness={0.6}        
            metalness={0.4}        
            toneMapped={false}
          />
        </instancedMesh>
      );
    };

    // 3. Planets (Scattered Mode Decoration)
    const PLANET_FACTS = [
      "Êää‰Ω†‰ΩìÂÜÖÁöÑDNAÊêìÊàê‰∏ÄÊù°Á∫øÁöÑËØùÔºåÂÆÉËÉΩÂª∂‰º∏100‰∫øËã±ÈáåÔºåÊØîÂú∞ÁêÉÂà∞ÂÜ•ÁéãÊòüÁöÑË∑ùÁ¶ªËøòËøú„ÄÇÊâÄ‰ª•ÂÖâÈù†‰Ω†Ëá™Â∑±Â∞±Ë∂≥Â§üÁ¶ªÂºÄÂ§™Èò≥Á≥ª‰∫Ü„ÄÇ",
      "‰∏ÄÊúµ‰∫ëÊúâÂ§öËΩªÂë¢ÔºüÂ§ßÁ∫¶‰∫îÂçÅ‰∏áÂÖ¨Êñ§„ÄÇ",
      "Â¶ÇÊûúÊàë‰ª¨ËÉΩÂ∞ùÂà∞ÁöÑËØùÔºåÈì∂Ê≤≥Á≥ª‰∏≠ÂøÉÂ∞ùËµ∑Êù•Â§ßÊ¶Ç‰ºöÂÉèË¶ÜÁõÜÂ≠êÂíåÊúóÂßÜÈÖíÁöÑÂë≥ÈÅì„ÄÇ",
      "ÊØè‰∏™‰∫∫ÁöÑ‰ΩìÂÜÖÔºåÈÉΩÂèØËÉΩÊã•ÊúâÊù•Ëá™Ë∂ÖÊñ∞ÊòüÁàÜÂèë‰∫ßÁîüÁöÑÈáçÂÖÉÁ¥†ÂéüÂ≠ê„ÄÇ‰Ω†ÊàëÁöÜÊòØÊòüÂ∞ò„ÄÇ",
      "ÁÅ´Êòü‰∏äÁöÑÊó•ËêΩÊòØËìùËâ≤ÁöÑ„ÄÇ",
      "Ê¥õÂ∏åÊûÅÈôêÊòØÊåáÂΩìÂ§©‰ΩìË∂äËøá‰∏¥ÁïåË∑ùÁ¶ªÊó∂ÔºåËæÉÂ∞èÂ§©‰ΩìË¢´ÊΩÆÊ±êÂäõÊíïË£ÇÊàêÁ¢éÁâáÔºåÁî®‰∏ÄÊ¨°Á≤âË∫´Á¢éÈ™®Êç¢‰∏Ä‰∏™Ê∞∏ÊÅíÁöÑÊã•Êä±„ÄÇ"
    ];

    const Planets = ({ setActiveFact }) => {
      // Tiny glowing planets
      const planetsData = useMemo(() => [
        { pos: [0, 6, 0], color: '#FFD700', size: 0.04, id: 0 },   
        { pos: [0, -6, 0], color: '#4169E1', size: 0.045, id: 1 },   
        { pos: [-7, 0, 2], color: '#FF69B4', size: 0.035, id: 2 },   
        { pos: [7, 0, -2], color: '#00FA9A', size: 0.04, id: 3 },  
        { pos: [2, 2, 6], color: '#FFA500', size: 0.03, id: 4 },   
        { pos: [-2, -2, -6], color: '#9370DB', size: 0.035, id: 5 }, 
      ], []);

      return (
        <group>
          {planetsData.map((data, index) => (
            <Float key={index} speed={1.5} rotationIntensity={0.5} floatIntensity={1}>
              <mesh 
                position={data.pos} 
                onClick={(e) => { e.stopPropagation(); setActiveFact(PLANET_FACTS[data.id]); }}
                onPointerOver={() => document.body.style.cursor = 'pointer'}
                onPointerOut={() => document.body.style.cursor = 'auto'}
              >
                <sphereGeometry args={[data.size, 32, 32]} />
                <meshStandardMaterial 
                  color={data.color} 
                  emissive={data.color} 
                  emissiveIntensity={4.0} 
                  toneMapped={false}
                />
              </mesh>
            </Float>
          ))}
        </group>
      );
    };

    // 4. Decorations (Text & Topper)
    const Decorations = ({ shape }) => {
      const fontUrl = "https://cdn.jsdelivr.net/npm/three/examples/fonts/helvetiker_regular.typeface.json";
      
      const letters = useMemo(() => {
        const treePhrase = "MERRY CHRISTMAS AND HAPPY NEW YEAR".split("").filter(c => c !== " ");
        const heartPhrase = "THROUGH ALL THE PAIN YOU STILL SHINE".split("").filter(c => c !== " ");

        return treePhrase.map((char, i) => {
          const t = i / treePhrase.length;
          const y = 3.5 - (t * 7); 
          const r = (4 - y) * 0.45 + 0.5;
          const angle = t * Math.PI * 6;
          
          const tHeart = (i / heartPhrase.length) * Math.PI * 2;
          const hx = 16 * Math.pow(Math.sin(tHeart), 3);
          const hy = 13 * Math.cos(tHeart) - 5 * Math.cos(2*tHeart) - 2 * Math.cos(3*tHeart) - Math.cos(4*tHeart);
          const scale = 0.22; 

          return {
            char: char,
            heartChar: heartPhrase[i % heartPhrase.length],
            treePos: [Math.cos(angle) * r, y, Math.sin(angle) * r],
            heartPos: [hx * scale, (hy * scale) + 1, 1.2],
            color: Math.random() > 0.5 ? "#FFF8DC" : "#E6E6FA",
            rot: [0, -angle, 0]
          };
        });
      }, []);

      return (
        <group>
          {shape === SHAPES.TREE && (
            <Float speed={2} rotationIntensity={0.5} floatIntensity={0.5}>
              <mesh position={[0, 4.2, 0]}>
                <sphereGeometry args={[0.3, 32, 32]} />
                <meshStandardMaterial 
                  color="#FFD700" 
                  emissive="#FFA500" 
                  emissiveIntensity={3} 
                  toneMapped={false} 
                />
              </mesh>
            </Float>
          )}

          {shape === SHAPES.HEART && (
             <Float speed={5} rotationIntensity={0} floatIntensity={0.5}>
               <Center position={[0, 0, 0]}>
                 <Text3D
                    font={fontUrl}
                    size={0.25}
                    height={0.05}
                    curveSegments={12}
                    bevelEnabled
                    bevelThickness={0.01}
                    bevelSize={0.005}
                 >
                   Loading...
                   <meshStandardMaterial 
                     color="#FFFFE0" 
                     emissive="#FFFF00" 
                     emissiveIntensity={2} 
                     toneMapped={false} 
                   />
                 </Text3D>
               </Center>
             </Float>
          )}

          {letters.map((item, i) => {
             if (shape === SHAPES.SCATTERED) return null;

             const isTree = shape === SHAPES.TREE;
             const pos = isTree ? item.treePos : item.heartPos;
             const rot = isTree ? item.rot : [0, 0, 0];
             const charToRender = isTree ? item.char : item.heartChar;
             const color = isTree ? item.color : "#FFFFE0"; 

             return (
              <Float key={i} speed={2} rotationIntensity={0.2} floatIntensity={0.2}>
                <Center position={pos} rotation={rot}>
                  <Text3D
                    font={fontUrl}
                    size={isTree ? 0.15 : 0.1}
                    height={0.02}
                    curveSegments={12}
                    bevelEnabled
                    bevelThickness={0.01}
                    bevelSize={0.002}
                    bevelOffset={0}
                    bevelSegments={3}
                  >
                    {charToRender}
                    <meshStandardMaterial color={color} emissive={color} emissiveIntensity={0.8} toneMapped={false} />
                  </Text3D>
                </Center>
              </Float>
             );
          })}
        </group>
      );
    };

    // 5. Meteor Shower
    const Meteors = ({ active }) => {
      const meshRef = useRef();
      const count = 800; 
      const dummy = useMemo(() => new THREE.Object3D(), []);
      
      const meteors = useMemo(() => {
        return new Array(count).fill(0).map(() => ({
          x: randomRange(-80, 80), 
          y: randomRange(30, 100), 
          z: randomRange(-40, 30),
          speed: randomRange(0.8, 2.5),
          len: randomRange(3, 8)
        }));
      }, []);

      useFrame(() => {
        if (!active || !meshRef.current) return;
        
        meteors.forEach((m, i) => {
          m.y -= m.speed;
          m.x -= m.speed * 0.5;
          if (m.y < -30) {
            m.y = randomRange(30, 100);
            m.x = randomRange(-80, 80);
          }
          dummy.position.set(m.x, m.y, m.z);
          dummy.rotation.set(0, 0, Math.PI / 4);
          dummy.scale.set(0.1, m.len, 0.1);
          dummy.updateMatrix();
          meshRef.current.setMatrixAt(i, dummy.matrix);
        });
        meshRef.current.instanceMatrix.needsUpdate = true;
      });

      if (!active) return null;

      return (
        <instancedMesh ref={meshRef} args={[null, null, count]}>
          <boxGeometry args={[1, 1, 1]} />
          <meshBasicMaterial color="#FFFFFF" transparent opacity={0.8} />
        </instancedMesh>
      );
    };

    // --- Main App Component ---
    const App = () => {
      const [shape, setShape] = useState(SHAPES.TREE);
      const [wishing, setWishing] = useState(false);
      const [countdown, setCountdown] = useState(null);
      const [activeFact, setActiveFact] = useState(null);
      const [sceneVisible, setSceneVisible] = useState(true);
      
      // Modes
      const [mode, setMode] = useState('I'); // 'I' for I-person (No Cam), 'E' for E-person (Cam)
      const [easterEggActive, setEasterEggActive] = useState(false);
      const [emojis, setEmojis] = useState([]);

      // Audio State
      const [isPlaying, setIsPlaying] = useState(false); 
      const [audioLocked, setAudioLocked] = useState(true);
      const [audioError, setAudioError] = useState(null);
      
      const audioRef = useRef(null);
      const currentTrackRef = useRef(SONGS.TREE);

      // Vision Refs
      const videoRef = useRef(null);
      const gestureRecognizerRef = useRef(null);
      const faceLandmarkerRef = useRef(null);
      const lastVideoTimeRef = useRef(-1);
      const requestRef = useRef(null);

      // --- Music Management ---
      useEffect(() => {
        const audio = document.getElementById('bg-music');
        if (!audio) return;
        
        audioRef.current = audio;
        audio.src = SONGS.TREE;
        audio.volume = 0.5;

        const onPlay = () => setIsPlaying(true);
        const onPause = () => setIsPlaying(false);
        const onError = (e) => {
          const errorCode = audio.error ? audio.error.code : 'unknown';
          let msg = "Error loading music.";
          if(errorCode === 4) msg = "Music file not found (404).";
          setAudioError(msg);
        };

        audio.addEventListener('play', onPlay);
        audio.addEventListener('pause', onPause);
        audio.addEventListener('error', onError);

        const attemptPlay = async () => {
          try {
            await audio.play();
            setAudioLocked(false);
          } catch (err) {
            setAudioLocked(true);
          }
        };
        attemptPlay();

        return () => {
          audio.removeEventListener('play', onPlay);
          audio.removeEventListener('pause', onPause);
          audio.removeEventListener('error', onError);
        };
      }, []);

      useEffect(() => {
        const audio = audioRef.current;
        if(!audio) return;

        let targetSrc = SONGS.TREE;
        if (wishing) targetSrc = SONGS.WISH;
        else {
          if (shape === SHAPES.TREE) targetSrc = SONGS.TREE;
          else targetSrc = SONGS.HEART_GALAXY;
        }

        if (currentTrackRef.current !== targetSrc) {
           currentTrackRef.current = targetSrc;
           const wasPlaying = !audio.paused;
           audio.src = targetSrc;
           if (wasPlaying) {
             audio.play().catch(e => console.log("Switch play error", e));
           }
        }
      }, [shape, wishing]);

      const handleUnlockAudio = () => {
        const audio = audioRef.current;
        if (audio) {
          audio.play().then(() => setAudioLocked(false)).catch(e => {});
        }
      };

      const toggleMusic = () => {
        const audio = audioRef.current;
        if (!audio) return;
        if (!audio.paused) audio.pause();
        else audio.play().catch(e => setAudioLocked(true));
      };

      // --- Vision / E-Mode Logic ---
      
      // Initialize Models
      useEffect(() => {
        const loadModels = async () => {
          try {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm");
            
            // Hand Gesture
            gestureRecognizerRef.current = await GestureRecognizer.createFromOptions(vision, {
              baseOptions: {
                modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task",
                delegate: "GPU"
              },
              runningMode: "VIDEO",
              numHands: 1
            });

            // Face Landmark
            faceLandmarkerRef.current = await FaceLandmarker.createFromOptions(vision, {
              baseOptions: {
                modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
                delegate: "GPU"
              },
              outputFaceBlendshapes: true,
              runningMode: "VIDEO",
              numFaces: 1
            });
          } catch (error) {
            console.error("Failed to load MediaPipe models", error);
          }
        };
        loadModels();
      }, []);

      // Toggle E/I Mode
      const toggleMode = async () => {
         if (mode === 'I') {
            // Switch to E-Mode (Enable Cam)
            try {
               const stream = await navigator.mediaDevices.getUserMedia({ video: true });
               if (videoRef.current) {
                 videoRef.current.srcObject = stream;
                 videoRef.current.addEventListener('loadeddata', predictWebcam);
                 setMode('E');
               }
            } catch (err) {
               alert("Cannot access webcam. Please check permissions.");
            }
         } else {
            // Switch to I-Mode (Disable Cam)
            if (videoRef.current && videoRef.current.srcObject) {
               const tracks = videoRef.current.srcObject.getTracks();
               tracks.forEach(track => track.stop());
               videoRef.current.srcObject = null;
            }
            if (requestRef.current) cancelAnimationFrame(requestRef.current);
            setMode('I');
         }
      };

      // Prediction Loop
      const predictWebcam = async () => {
         const video = videoRef.current;
         const gestureRecognizer = gestureRecognizerRef.current;
         const faceLandmarker = faceLandmarkerRef.current;

         if (!video || !gestureRecognizer || !faceLandmarker) return;

         let nowInMs = Date.now();
         if (video.currentTime !== lastVideoTimeRef.current) {
            lastVideoTimeRef.current = video.currentTime;
            
            // 1. Hand Gestures
            const gestureResult = gestureRecognizer.recognizeForVideo(video, nowInMs);
            if (gestureResult.gestures.length > 0) {
               const category = gestureResult.gestures[0][0].categoryName;
               // Map Gestures
               if (category === 'Open_Palm') setShape(SHAPES.SCATTERED);
               else if (category === 'Closed_Fist') setShape(SHAPES.TREE);
               else if (category === 'Victory' || category === 'ILoveYou' || category === 'Thumb_Up') setShape(SHAPES.HEART);
               else if (category === 'Pointing_Up') {
                  // Trigger click/interaction: here we just simulate button click logic by random effect or just console
                  // For better UX, Pointing Up acts as "Interact" -> Random color shift or just log
               }
            }

            // 2. Face Expression (Kiss Easter Egg)
            const faceResult = faceLandmarker.detectForVideo(video, nowInMs);
            if (faceResult.faceBlendshapes && faceResult.faceBlendshapes.length > 0 && faceResult.faceBlendshapes[0].categories) {
               const blendshapes = faceResult.faceBlendshapes[0].categories;
               const puckerScore = blendshapes.find(s => s.categoryName === 'mouthPucker')?.score || 0;
               
               if (puckerScore > 0.5 && !easterEggActive) {
                  triggerEasterEgg();
               }
            }
         }
         requestRef.current = requestAnimationFrame(predictWebcam);
      };

      const triggerEasterEgg = () => {
         setEasterEggActive(true);
         // Spawn emojis
         const newEmojis = Array.from({ length: 20 }).map((_, i) => ({
            id: i,
            left: Math.random() * 90 + '%',
            delay: Math.random() * 1 + 's'
         }));
         setEmojis(newEmojis);

         setTimeout(() => {
            setEasterEggActive(false);
            setEmojis([]);
         }, 3000);
      };

      // Wish Logic
      const handleWish = () => {
        setSceneVisible(false);
        setShape(SHAPES.SCATTERED); 
        setCountdown(10);
      };

      const dismissWish = () => {
        setWishing(false);
        setSceneVisible(true);
        setShape(SHAPES.TREE);
      };

      useEffect(() => {
        if (countdown === null) return;
        if (countdown > 0) {
          const timer = setTimeout(() => setCountdown(c => c - 1), 1000);
          return () => clearTimeout(timer);
        } else {
          setCountdown(null);
          setWishing(true);
          const fx = document.getElementById('meteor-fx');
          if(fx) {
            fx.volume = 1.0;
            fx.currentTime = 0;
            fx.play().catch(e => {});
          }
        }
      }, [countdown]);

      return (
        <>
          {/* Unlock Overlay */}
          {audioLocked && !audioError && (
            <div 
              className="absolute inset-0 z-[100] flex items-center justify-center bg-black/80 cursor-pointer"
              onClick={handleUnlockAudio}
            >
              <div className="text-center animate-pulse">
                <p className="text-2xl text-yellow-200 font-serif mb-2">Click anywhere to start the magic</p>
                <p className="text-sm text-white/50">(Tap to enable music)</p>
              </div>
            </div>
          )}

          {/* Audio Error Notification */}
          {audioError && (
             <div className="absolute top-0 left-1/2 -translate-x-1/2 bg-red-900/80 text-white px-4 py-2 text-xs z-[100]">
               {audioError}
             </div>
          )}
          
          {/* Webcam Container (Visible in E-Mode) */}
          <div id="webcam-container" style={{ display: mode === 'E' ? 'block' : 'none' }}>
            <video ref={videoRef} autoPlay playsInline muted></video>
          </div>

          {/* E/I Mode Toggle (Top Right) */}
          <button 
             onClick={toggleMode}
             className="absolute top-6 right-6 z-50 bg-white/10 hover:bg-white/20 backdrop-blur text-white border border-white/30 px-4 py-2 rounded-full font-serif text-sm transition-all"
          >
             {mode === 'I' ? 'I‰∫∫Ê®°Âºè (Cam Off)' : 'E‰∫∫Ê®°Âºè (Cam On)'}
          </button>

          {/* Easter Egg Overlay */}
          {easterEggActive && (
             <div className="absolute inset-0 z-[60] flex items-center justify-center pointer-events-none">
                <h2 className="text-5xl md:text-7xl text-pink-300 font-bold drop-shadow-lg animate-bounce">ÊÅ≠Âñú‰Ω†ÂèëÁé∞ÂΩ©ËõãÔºÅ</h2>
                {emojis.map(e => (
                   <div key={e.id} className="emoji-particle" style={{ left: e.left, animationDelay: e.delay }}>üòò</div>
                ))}
             </div>
          )}

          <Canvas camera={{ position: [0, 0, 15], fov: 60 }} dpr={[1, 2]}>
            <Suspense fallback={<Loader />}>
              <color attach="background" args={['#000010']} />
              <Stars radius={100} depth={50} count={5000} factor={4} saturation={0} fade speed={1} />
              
              <ambientLight intensity={0.8} />
              <pointLight position={[10, 10, 10]} intensity={2.0} />
              <pointLight position={[-10, -10, -10]} intensity={1.0} />

              <group visible={sceneVisible}>
                <MagicParticles shape={shape} />
                <Decorations shape={shape} />
                {shape === SHAPES.SCATTERED && <Planets setActiveFact={setActiveFact} />}
              </group>

              <Meteors active={wishing} />

              <EffectComposer>
                <Bloom luminanceThreshold={0.5} luminanceSmoothing={0.9} height={300} intensity={1.5} />
                <Vignette eskil={false} offset={0.1} darkness={1.1} />
              </EffectComposer>
              
              <OrbitControls 
                enableZoom={true} 
                enablePan={false} 
                rotateSpeed={0.5} 
                minDistance={5} 
                maxDistance={30}
              />
            </Suspense>
          </Canvas>

          {/* Top Left Title */}
          <div className="absolute top-6 left-6 text-white z-10 pointer-events-none">
            <h1 className="text-2xl font-serif tracking-widest text-yellow-100 drop-shadow-[0_0_10px_rgba(255,215,0,0.5)]">
              Merry Christmas & Happy New Year!
            </h1>
          </div>

          {/* Bottom Right Controls */}
          {sceneVisible && (
            <div className="absolute bottom-6 right-6 flex flex-col gap-4 z-20 items-end">
              <button 
                onClick={toggleMusic}
                className={`w-12 h-12 rounded-full border border-white/30 backdrop-blur-md flex items-center justify-center transition-all hover:scale-110 hover:bg-white/20 ${isPlaying ? 'text-green-300' : 'text-white/70'}`}
                title={isPlaying ? "Pause Music" : "Play Music"}
              >
                {isPlaying ? (
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6">
                    <path strokeLinecap="round" strokeLinejoin="round" d="M15.75 5.25v13.5m-7.5-13.5v13.5" />
                  </svg>
                ) : (
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6">
                    <path strokeLinecap="round" strokeLinejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z" />
                  </svg>
                )}
              </button>

              <button 
                onClick={handleWish}
                className="bg-gradient-to-r from-yellow-200 to-amber-400 text-black font-serif px-8 py-3 rounded-full shadow-[0_0_20px_rgba(255,215,0,0.6)] hover:scale-105 transition-transform"
              >
                Make a Wish
              </button>
            </div>
          )}

          {/* Bottom Center Shape Controls */}
          {sceneVisible && (
            <div className="absolute bottom-6 left-1/2 -translate-x-1/2 flex gap-6 z-20">
              <button onClick={() => setShape(SHAPES.TREE)} className={`text-white/80 hover:text-white transition-colors ${shape === SHAPES.TREE ? 'font-bold text-yellow-200' : ''}`}>TREE</button>
              <button onClick={() => setShape(SHAPES.HEART)} className={`text-white/80 hover:text-white transition-colors ${shape === SHAPES.HEART ? 'font-bold text-pink-200' : ''}`}>HEART</button>
              <button onClick={() => setShape(SHAPES.SCATTERED)} className={`text-white/80 hover:text-white transition-colors ${shape === SHAPES.SCATTERED ? 'font-bold text-blue-200' : ''}`}>GALAXY</button>
            </div>
          )}

          {/* Countdown Overlay */}
          {countdown !== null && (
            <div className="absolute inset-0 flex items-center justify-center pointer-events-none z-50">
              <div className="text-[15rem] text-yellow-100 countdown-text drop-shadow-[0_0_50px_rgba(255,215,0,0.8)]">
                {countdown}
              </div>
            </div>
          )}

          {/* Wish Message Overlay */}
          {wishing && (
            <div 
              className="absolute inset-0 flex flex-col items-center justify-center z-50 bg-black/20 cursor-pointer"
              onClick={dismissWish}
            >
              <h2 className="text-4xl md:text-6xl text-transparent bg-clip-text bg-gradient-to-r from-yellow-100 via-white to-yellow-100 font-serif drop-shadow-[0_0_30px_rgba(255,255,255,0.8)] animate-pulse mb-4 pointer-events-none">
                Your wish will come true!!!!
              </h2>
              <p className="text-sm text-white/80 font-light tracking-widest font-serif italic pointer-events-none">
                Êàë‰ºöÂíå‰Ω†‰∏ÄËµ∑ÂÆûÁé∞
              </p>
              <div className="absolute bottom-10 text-white/30 text-xs pointer-events-none">Click anywhere to return</div>
            </div>
          )}

          {/* Planet Fact Overlay */}
          {activeFact && (
            <div className="absolute inset-0 flex items-center justify-center z-50 bg-black/60 backdrop-blur-sm" onClick={() => setActiveFact(null)}>
              <div className="bg-slate-900/90 border border-white/20 p-8 rounded-2xl max-w-lg mx-4 text-center shadow-[0_0_50px_rgba(100,200,255,0.2)]" onClick={e => e.stopPropagation()}>
                <p className="text-blue-100 text-lg leading-relaxed font-serif">
                  {activeFact}
                </p>
                <button 
                  onClick={() => setActiveFact(null)}
                  className="mt-6 text-sm text-white/50 hover:text-white transition-colors"
                >
                  Close
                </button>
              </div>
            </div>
          )}
        </>
      );
    };

    const root = createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>