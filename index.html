<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Merry Christmas & Happy New Year</title>
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- Import Map -->
  <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "three": "https://esm.sh/three@0.160.0",
        "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.12?deps=three@0.160.0,react@18.2.0",
        "@react-three/drei": "https://esm.sh/@react-three/drei@9.96.1?deps=three@0.160.0,react@18.2.0,@react-three/fiber@8.15.12",
        "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0?deps=three@0.160.0,react@18.2.0,@react-three/fiber@8.15.12,postprocessing@6.34.1",
        "postprocessing": "https://esm.sh/postprocessing@6.34.1?deps=three@0.160.0",
        "maath/random/dist/maath-random.esm": "https://esm.sh/maath@0.10.7/random/dist/maath-random.esm",
        "framer-motion": "https://esm.sh/framer-motion@10.16.4?deps=react@18.2.0",
        "uuid": "https://esm.sh/uuid@9.0.1",
        "@mediapipe/tasks-vision": "https://esm.sh/@mediapipe/tasks-vision@0.10.9"
      }
    }
  </script>

  <!-- Babel for JSX -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #050510; }
    #root { width: 100%; height: 100%; }
    
    /* Hide scrollbars */
    ::-webkit-scrollbar { display: none; }
    
    /* Custom Animations */
    @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
    .fade-out { animation: fadeOut 1s forwards; }

    @keyframes pulse {
      0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
      50% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.8; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    
    .file-upload-overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 40;
      opacity: 0;
      width: 40px;
      height: 40px;
      overflow: hidden;
      cursor: pointer;
    }
    .file-upload-overlay:hover { opacity: 0.5; }
    
    /* Loading overlay */
    #loader {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #000;
      color: #50C878;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      font-family: monospace;
      font-size: 1.5rem;
      transition: opacity 1s ease;
    }
  </style>
</head>
<body>
  <div id="loader">Loading Christmas Magic...</div>
  <div id="root"></div>

  <!-- Audio Element (Background Music) -->
  <audio id="bg-music" loop crossorigin="anonymous" style="display:none;">
    <source src="https://cdn.pixabay.com/audio/2022/12/13/audio_65191837b2.mp3" type="audio/mpeg">
  </audio>

  <!-- Audio Element (Meteor Sound Effect) -->
  <audio id="meteor-fx" crossorigin="anonymous" style="display:none;">
    <!-- Magical wind chimes / sparkle sound -->
    <source src="https://cdn.pixabay.com/audio/2022/10/28/audio_24345d4715.mp3" type="audio/mpeg">
  </audio>

  <script type="text/babel" data-type="module">
    import React, { useState, useRef, useMemo, useEffect, Suspense } from 'react';
    import { createRoot } from 'react-dom/client';
    import * as THREE from 'three';
    import { Canvas, useFrame, useThree } from '@react-three/fiber';
    import { 
      OrbitControls, 
      Stars, 
      Float, 
      Text3D, 
      Center, 
      Sparkles, 
      Image as DreiImage
    } from '@react-three/drei';
    import {
      EffectComposer, 
      Bloom,
      Vignette
    } from '@react-three/postprocessing';
    import * as random from 'maath/random/dist/maath-random.esm';
    
    // --- Constants ---
    const COLORS = {
      midnight: '#191970',
      ice: '#A5F2F3',
      snow: '#FFFAFA',
      gold: '#FFD700',
      silver: '#C0C0C0',
      emerald: '#50C878',
      warmLight: '#ffaa00'
    };

    const SHAPES = {
      SCATTERED: 'SCATTERED',
      TREE: 'TREE',
      HEART: 'HEART'
    };

    const PARTICLE_COUNT = 3000; // Dense tree

    // --- Utils ---
    
    // Helper to generate Tree Spiral positions
    const getTreePosition = (i) => {
      const y = (i / PARTICLE_COUNT) * 10 - 5; // Height from -5 to 5
      const radius = (1 - (y + 5) / 10) * 3.5; // Cone shape
      const angle = i * 0.5; // Spiral tightness
      const x = radius * Math.cos(angle);
      const z = radius * Math.sin(angle);
      return new THREE.Vector3(x, y, z);
    };

    // Helper for Heart positions
    const getHeartPosition = (i) => {
      const t = (i / PARTICLE_COUNT) * Math.PI * 2;
      // Parametric heart equation
      const x = 16 * Math.pow(Math.sin(t), 3);
      const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
      const scale = 0.25;
      // Distribute points inside the heart volume roughly
      const r = Math.random();
      return new THREE.Vector3(x * scale * r, y * scale * r + 2, (Math.random() - 0.5) * 2);
    };

    // Helper for Scattered positions
    const getScatteredPosition = () => {
      const p = random.inSphere(new Float32Array(3), { radius: 8 });
      return new THREE.Vector3(p[0], p[1], p[2]);
    };

    // --- Components ---

    // 1. Particle System (The Tree/Morphing Entity)
    const MagicParticles = ({ shape, audioAnalyser }) => {
      const meshRef = useRef();
      const { viewport } = useThree();
      
      // Generate target positions for all states once
      const positions = useMemo(() => {
        const tree = new Float32Array(PARTICLE_COUNT * 3);
        const heart = new Float32Array(PARTICLE_COUNT * 3);
        const scattered = new Float32Array(PARTICLE_COUNT * 3);

        for (let i = 0; i < PARTICLE_COUNT; i++) {
          const t = getTreePosition(i);
          tree[i * 3] = t.x; tree[i * 3 + 1] = t.y; tree[i * 3 + 2] = t.z;

          const h = getHeartPosition(i);
          heart[i * 3] = h.x; heart[i * 3 + 1] = h.y; heart[i * 3 + 2] = h.z;

          const s = getScatteredPosition();
          scattered[i * 3] = s.x; scattered[i * 3 + 1] = s.y; scattered[i * 3 + 2] = s.z;
        }
        return { [SHAPES.TREE]: tree, [SHAPES.HEART]: heart, [SHAPES.SCATTERED]: scattered };
      }, []);

      // Current visible positions
      const currentPositions = useMemo(() => new Float32Array(positions[SHAPES.SCATTERED]), []);
      
      // Dummy object for instanced mesh matrix calculation
      const dummy = useMemo(() => new THREE.Object3D(), []);

      useFrame((state, delta) => {
        if (!meshRef.current) return;

        // Audio reactivity
        let audioScale = 1;
        if (audioAnalyser) {
           const data = audioAnalyser.getFrequencyData();
           const avg = data.reduce((a, b) => a + b, 0) / data.length;
           audioScale = 1 + (avg / 255) * 0.2; // Mild beat pulse
        }

        const target = positions[shape];
        const lerpSpeed = 3 * delta; // Smooth spring-like interpolation

        // Update individual particles
        for (let i = 0; i < PARTICLE_COUNT; i++) {
          const ix = i * 3;
          const iy = i * 3 + 1;
          const iz = i * 3 + 2;

          // Morph logic: Linear interpolation
          currentPositions[ix] += (target[ix] - currentPositions[ix]) * lerpSpeed;
          currentPositions[iy] += (target[iy] - currentPositions[iy]) * lerpSpeed;
          currentPositions[iz] += (target[iz] - currentPositions[iz]) * lerpSpeed;

          // Breathing / Glitter effect
          const breathing = Math.sin(state.clock.elapsedTime * 2 + i) * 0.05;
          
          dummy.position.set(
            currentPositions[ix],
            currentPositions[iy],
            currentPositions[iz]
          );
          
          // Rotation for star sparkle
          dummy.rotation.set(
            Math.sin(state.clock.elapsedTime + i),
            Math.cos(state.clock.elapsedTime + i),
            0
          );
          
          const scale = (i % 5 === 0 ? 0.15 : 0.08) * audioScale + breathing; // Randomize star sizes slightly
          dummy.scale.set(scale, scale, scale);

          dummy.updateMatrix();
          meshRef.current.setMatrixAt(i, dummy.matrix);
        }
        meshRef.current.instanceMatrix.needsUpdate = true;
      });

      // Star shape geometry
      const starShape = useMemo(() => {
          const shape = new THREE.Shape();
          const points = 5;
          const outerRadius = 0.5;
          const innerRadius = 0.2;
          for (let i = 0; i < points * 2; i++) {
            const angle = (i * Math.PI) / points;
            const r = i % 2 === 0 ? outerRadius : innerRadius;
            const x = Math.cos(angle) * r;
            const y = Math.sin(angle) * r;
            if (i === 0) shape.moveTo(x, y);
            else shape.lineTo(x, y);
          }
          shape.closePath();
          return shape;
      }, []);

      const starGeometry = useMemo(() => new THREE.ExtrudeGeometry(starShape, { depth: 0.1, bevelEnabled: false }), [starShape]);

      return (
        <instancedMesh ref={meshRef} args={[starGeometry, null, PARTICLE_COUNT]}>
          <meshStandardMaterial 
            color={COLORS.emerald} 
            emissive={COLORS.emerald}
            emissiveIntensity={0.5}
            roughness={0.4}
            metalness={0.8}
            toneMapped={false}
          />
        </instancedMesh>
      );
    };

    // 2. Decorations (Text & Moon)
    const Decorations = ({ shape }) => {
      const fontUrl = 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/fonts/helvetiker_regular.typeface.json';

      // Phrases: MERRY CHRISTMAS LOVE YOU HAPPY NEW YEAR
      // Scattered as individual letters
      const decorationsLayout = useMemo(() => {
          const text = "MERRYCHRISTMASLOVEYOUHAPPYNEWYEAR";
          const chars = text.split('');
          
          // Fisher-Yates shuffle
          for (let i = chars.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [chars[i], chars[j]] = [chars[j], chars[i]];
          }
          
          const items = [];
          
          chars.forEach((char, i) => {
              // Distribute randomly on the cone surface
              // Height from -4 to 4 (Tree spans roughly -5 to 5, keeping it slightly centered)
              const y = (Math.random() * 8) - 4; 
              
              // Radius of cone at this height
              // Tree logic: radius = (1 - (y + 5) / 10) * 3.5 approximately
              // We calculate it: at y=-5 r=3.5, at y=5 r=0.
              const radiusBase = (5 - y) * 0.35; 
              
              // Add slightly random offset to radius so they hover nicely
              const r = radiusBase + 0.2;

              const angle = Math.random() * Math.PI * 2;
              
              const x = Math.sin(angle) * r;
              const z = Math.cos(angle) * r;
              
              // Rotation: Face outward
              const rotY = angle; 
              
              // Randomize color between Pale Gold and Pale Silver
              const isGold = Math.random() > 0.5;
              const color = isGold ? '#FFF8DC' : '#E6E6FA'; // Cornsilk or Lavender
              
              items.push({
                  char,
                  position: [x, y, z],
                  rotation: [0, rotY, 0],
                  color
              });
          });
          return items;
      }, []);

      return (
        <group>
          {/* Tree Topper (Moon) - Only visible in TREE state */}
          <group visible={shape === SHAPES.TREE}>
            <Float speed={2} rotationIntensity={0.2} floatIntensity={0.5} position={[0, 5.2, 0]}>
               {/* Smaller Crescent Moon */}
               <Text3D 
                  font={fontUrl} 
                  size={0.35} 
                  height={0.05}
                  rotation={[0, 0, Math.PI / 3]} // Tilted C to look like crescent
               >
                  C
                  <meshStandardMaterial 
                    color="#FFD700" 
                    emissive="#FFD700" 
                    emissiveIntensity={1} 
                    toneMapped={false} 
                  />
               </Text3D>
            </Float>
          </group>

          {/* Scattered Letters Decorating the Tree */}
          <group visible={shape === SHAPES.TREE}>
            {decorationsLayout.map((item, i) => (
                <Float key={i} speed={2} rotationIntensity={0.5} floatIntensity={0.2} position={item.position}>
                    <group rotation={item.rotation}>
                        <Text3D 
                            font={fontUrl} 
                            size={0.18} 
                            height={0.02} 
                            bevelEnabled
                            bevelThickness={0.01}
                            bevelSize={0.005}
                        >
                            {item.char}
                            <meshStandardMaterial 
                                color={item.color} 
                                emissive={item.color}
                                emissiveIntensity={0.6}
                                metalness={0.9} 
                                roughness={0.1}
                                toneMapped={false}
                            />
                        </Text3D>
                    </group>
                </Float>
            ))}
          </group>
        </group>
      );
    };

    // 3. Photo Wall
    const PhotoWall = ({ shape, photos, onPhotoClick }) => {
       // Position photos spirally on the tree
       if (shape !== SHAPES.TREE) return null;

       return (
         <group>
           {photos.map((url, i) => {
             const y = (i / (photos.length || 1)) * 6 - 3;
             const angle = i * 2.5 + Math.PI; // Offset from text slightly
             const radius = (1 - (y + 5) / 10) * 4.0; 
             return (
               <Float key={i} speed={1.5} rotationIntensity={0.5} floatIntensity={0.5}>
                 <group 
                    position={[Math.sin(angle) * radius, y, Math.cos(angle) * radius]} 
                    rotation={[0, -angle + Math.PI/2, 0]}
                    onClick={(e) => { e.stopPropagation(); onPhotoClick(url); }}
                 >
                   <DreiImage 
                     url={url} 
                     scale={[1, 1]} 
                     transparent 
                     opacity={0.9}
                   />
                   {/* Frame */}
                   <mesh position={[0, 0, -0.01]}>
                      <planeGeometry args={[1.1, 1.1]} />
                      <meshStandardMaterial color={COLORS.silver} metalness={1} />
                   </mesh>
                 </group>
               </Float>
             );
           })}
         </group>
       );
    };

    // 4. Meteor Shower (Make a Wish)
    const Meteors = ({ active }) => {
      const count = 50;
      const positions = useMemo(() => new Float32Array(count * 3), []);
      const speeds = useMemo(() => new Float32Array(count), []);
      const meshRef = useRef();

      // Init positions high up
      useMemo(() => {
        for(let i=0; i<count; i++) {
           positions[i*3] = (Math.random() - 0.5) * 30;
           positions[i*3+1] = 10 + Math.random() * 20;
           positions[i*3+2] = (Math.random() - 0.5) * 20;
           speeds[i] = 0.2 + Math.random() * 0.4;
        }
      }, []);

      useFrame(() => {
         if (!active || !meshRef.current) return;
         for(let i=0; i<count; i++) {
            // Move down and slightly left
            positions[i*3] -= speeds[i]; // x
            positions[i*3+1] -= speeds[i] * 2; // y
            
            // Reset if below floor
            if(positions[i*3+1] < -10) {
                positions[i*3] = (Math.random() - 0.5) * 30;
                positions[i*3+1] = 20 + Math.random() * 10;
            }
         }
         meshRef.current.instanceMatrix.needsUpdate = true;
         // Update matrix for each instance
         const dummy = new THREE.Object3D();
         for(let i=0; i<count; i++) {
            dummy.position.set(positions[i*3], positions[i*3+1], positions[i*3+2]);
            // Rotate to look like streak
            dummy.rotation.z = Math.PI / 4;
            dummy.scale.set(0.05, 1.5, 0.05); // Longer tail
            dummy.updateMatrix();
            meshRef.current.setMatrixAt(i, dummy.matrix);
         }
      });

      if (!active) return null;

      return (
        <instancedMesh ref={meshRef} args={[null, null, count]}>
           <cylinderGeometry args={[0.05, 0, 1, 4]} />
           <meshBasicMaterial color={COLORS.snow} />
        </instancedMesh>
      );
    };

    // --- Main App Logic ---

    const App = () => {
      const [shape, setShape] = useState(SHAPES.TREE);
      const [photos, setPhotos] = useState([]); // Default empty
      const [activePhoto, setActivePhoto] = useState(null);
      const [wishing, setWishing] = useState(false);
      const [countdown, setCountdown] = useState(null);
      const [analyser, setAnalyser] = useState(null);
      
      // Audio Setup
      useEffect(() => {
        const audioEl = document.getElementById('bg-music');
        const playMusic = () => {
             if(audioEl.paused) {
                 audioEl.play().catch(e => console.log("Audio autoplay blocked", e));
                 // Context setup
                 try {
                    const ctx = new (window.AudioContext || window.webkitAudioContext)();
                    const src = ctx.createMediaElementSource(audioEl);
                    const node = ctx.createAnalyser();
                    node.fftSize = 64;
                    src.connect(node);
                    node.connect(ctx.destination);
                    
                    const dataArray = new Uint8Array(node.frequencyBinCount);
                    setAnalyser({ 
                        getFrequencyData: () => {
                            node.getByteFrequencyData(dataArray);
                            return dataArray;
                        }
                    });
                 } catch(e) { console.warn("Audio Context Error", e); }
             }
        };
        document.body.addEventListener('click', playMusic, { once: true });
      }, []);

      // Hand Gesture Setup (Keys for fallback)
      useEffect(() => {
         const handleKeys = (e) => {
             if (e.key === '1') setShape(SHAPES.TREE);
             if (e.key === '2') setShape(SHAPES.SCATTERED);
             if (e.key === '3') setShape(SHAPES.HEART);
         };
         window.addEventListener('keydown', handleKeys);
         return () => window.removeEventListener('keydown', handleKeys);
      }, []);

      // Make a Wish Logic with Countdown
      const handleWish = () => {
          if(wishing || countdown !== null) return;
          setCountdown(10);
      };

      useEffect(() => {
        if (countdown === null) return;
        
        if (countdown > 0) {
            const timer = setTimeout(() => setCountdown(c => c - 1), 1000);
            return () => clearTimeout(timer);
        } else {
            // Countdown finished
            setCountdown(null);
            setWishing(true);
            
            // Play Sound
            const sound = document.getElementById('meteor-fx');
            if(sound) {
                sound.volume = 0.5;
                sound.currentTime = 0;
                sound.play().catch(e => console.warn('FX blocked', e));
            }

            // Stop meteors after 10s
            setTimeout(() => setWishing(false), 10000);
        }
      }, [countdown]);

      // File Upload Handler
      const handleFileUpload = (e) => {
          const file = e.target.files[0];
          if (file) {
              const url = URL.createObjectURL(file);
              setPhotos(prev => [...prev, url]);
          }
      };
      
      const removeLoader = () => {
          const loader = document.getElementById('loader');
          if (loader) {
             loader.classList.add('fade-out');
             setTimeout(() => loader.remove(), 1000);
          }
      };

      return (
        <>
          {/* Hidden File Input for Custom Photos */}
          <input 
             type="file" 
             accept="image/*" 
             className="file-upload-overlay" 
             onChange={handleFileUpload} 
             title="Upload Photo"
          />

          {/* Active Photo Overlay */}
          {activePhoto && (
            <div 
                style={{
                    position: 'absolute', top:0, left:0, width:'100%', height:'100%', 
                    background:'rgba(0,0,0,0.8)', zIndex: 100, display:'flex', 
                    justifyContent:'center', alignItems:'center', cursor:'pointer'
                }}
                onClick={() => setActivePhoto(null)}
            >
                <img src={activePhoto} style={{maxHeight:'80%', maxWidth:'90%', border: '4px solid gold', borderRadius: '10px'}} />
            </div>
          )}

          {/* Countdown Overlay */}
          {countdown !== null && (
             <div style={{
                 position: 'absolute', 
                 top: '40%', 
                 left: '50%', 
                 transform: 'translate(-50%, -50%)', 
                 zIndex: 60,
                 fontSize: '8rem',
                 fontWeight: 'bold',
                 color: '#FFD700',
                 textShadow: '0 0 30px #FFD700, 0 0 60px #FFA500',
                 fontFamily: 'serif',
                 pointerEvents: 'none',
                 animation: 'pulse 1s infinite'
             }}>
                 {countdown}
             </div>
          )}
          
          {/* Controls UI */}
          <div style={{position: 'absolute', bottom: 20, left: 20, zIndex: 10, display: 'flex', gap: '10px'}}>
             <button onClick={() => setShape(SHAPES.TREE)} className="px-4 py-2 bg-green-900/50 text-gold rounded hover:bg-green-800 text-xs text-yellow-500">TREE</button>
             <button onClick={() => setShape(SHAPES.HEART)} className="px-4 py-2 bg-red-900/50 text-gold rounded hover:bg-red-800 text-xs text-yellow-500">HEART</button>
             <button onClick={() => setShape(SHAPES.SCATTERED)} className="px-4 py-2 bg-blue-900/50 text-gold rounded hover:bg-blue-800 text-xs text-yellow-500">SCATTER</button>
          </div>

          {/* Make a Wish Button */}
          <div style={{
              position: 'absolute', 
              bottom: '50px', 
              width: '100%', 
              display: 'flex', 
              justifyContent: 'center', 
              zIndex: 50, 
              pointerEvents: 'none'
          }}>
            <button 
               onClick={handleWish}
               disabled={wishing || countdown !== null}
               style={{
                   pointerEvents: 'auto', 
                   background: 'rgba(255, 215, 0, 0.1)', 
                   border: '1px solid rgba(255, 215, 0, 0.5)', 
                   color: '#FFD700', 
                   padding: '12px 30px', 
                   borderRadius: '30px', 
                   cursor: 'pointer', 
                   fontFamily: 'sans-serif', 
                   textTransform: 'uppercase', 
                   letterSpacing: '2px', 
                   backdropFilter: 'blur(4px)',
                   fontSize: '0.9rem',
                   boxShadow: '0 0 15px rgba(255, 215, 0, 0.2)',
                   transition: 'all 0.3s ease',
                   opacity: (wishing || countdown !== null) ? 0.5 : 1
               }}
               onMouseEnter={(e) => {
                   if(wishing || countdown !== null) return;
                   e.target.style.background = 'rgba(255, 215, 0, 0.3)';
                   e.target.style.boxShadow = '0 0 25px rgba(255, 215, 0, 0.5)';
               }}
               onMouseLeave={(e) => {
                   if(wishing || countdown !== null) return;
                   e.target.style.background = 'rgba(255, 215, 0, 0.1)';
                   e.target.style.boxShadow = '0 0 15px rgba(255, 215, 0, 0.2)';
               }}
            >
               {wishing ? 'Wishing...' : countdown !== null ? 'Get Ready...' : 'Make a Wish'}
            </button>
          </div>

          <Canvas 
             camera={{ position: [0, 0, 10], fov: 60 }}
             onCreated={removeLoader}
             gl={{ antialias: false, toneMapping: THREE.ReinhardToneMapping, toneMappingExposure: 1.5 }}
          >
             <color attach="background" args={[COLORS.midnight]} />
             
             {/* Scene Lighting */}
             <ambientLight intensity={0.5} />
             <pointLight position={[10, 10, 10]} intensity={1} color={COLORS.gold} />
             <pointLight position={[-10, -10, -5]} intensity={0.5} color={COLORS.ice} />
             
             {/* Background */}
             <Stars radius={100} depth={50} count={5000} factor={4} saturation={0} fade speed={1} />
             <Sparkles count={200} scale={12} size={2} speed={0.4} opacity={0.5} color={COLORS.ice} />

             {/* Main Content */}
             <group position={[0, -2, 0]}>
                <MagicParticles shape={shape} audioAnalyser={analyser} />
                <Decorations shape={shape} />
                <PhotoWall shape={shape} photos={photos} onPhotoClick={setActivePhoto} />
                <Meteors active={wishing} />
             </group>

             {/* Post Processing */}
             <EffectComposer disableNormalPass>
                <Bloom luminanceThreshold={0.5} mipmapBlur intensity={1.5} radius={0.4} />
                <Vignette eskil={false} offset={0.1} darkness={1.1} />
             </EffectComposer>

             <OrbitControls 
                enablePan={false} 
                enableZoom={true} 
                maxDistance={20} 
                minDistance={5} 
                autoRotate={shape === SHAPES.TREE && !activePhoto} 
                autoRotateSpeed={0.5}
             />
          </Canvas>
        </>
      );
    };

    const root = createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>