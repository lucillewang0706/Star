
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Merry Christmas & Happy New Year</title>
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- Import Map: Modern Stack (Three 0.160.0) to fix colorspace_fragment errors -->
  <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
        "three": "https://esm.sh/three@0.160.0",
        "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.12?external=react,react-dom,three",
        "@react-three/drei": "https://esm.sh/@react-three/drei@9.96.1?external=react,react-dom,three,@react-three/fiber",
        "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0?external=react,react-dom,three,@react-three/fiber",
        "postprocessing": "https://esm.sh/postprocessing@6.34.1?external=three",
        "uuid": "https://esm.sh/uuid@9.0.1"
      }
    }
  </script>

  <!-- Babel -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #000010; }
    #root { width: 100%; height: 100%; }
    
    @keyframes pulse-glow {
      0%, 100% { text-shadow: 0 0 20px #FFD700, 0 0 40px #FFA500; transform: scale(1); }
      50% { text-shadow: 0 0 40px #FFD700, 0 0 80px #FFA500; transform: scale(1.1); }
    }
    .countdown-text {
      font-family: 'Times New Roman', serif;
      animation: pulse-glow 1s infinite ease-in-out;
    }
    .loading-text {
      animation: pulse 2s infinite;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- Background Music Audio Element -->
  <audio id="bg-music" loop>
    <source src="https://cdn.pixabay.com/download/audio/2022/11/22/audio_febc508520.mp3?filename=christmas-magic-127058.mp3" type="audio/mpeg">
  </audio>

  <!-- Meteor Sound Effect -->
  <audio id="meteor-fx">
    <source src="https://cdn.pixabay.com/download/audio/2022/03/24/audio_338a906253.mp3?filename=magic-chime-02-6014.mp3" type="audio/mpeg">
  </audio>

  <script type="text/babel" data-type="module">
    import React, { useState, useRef, useMemo, useEffect, Suspense } from 'react';
    import { createRoot } from 'react-dom/client';
    import * as THREE from 'three';
    import { Canvas, useFrame, useThree } from '@react-three/fiber';
    import { OrbitControls, PerspectiveCamera, Stars, Float, Text3D, Center, Sparkles, Html } from '@react-three/drei';
    import { EffectComposer, Bloom, Vignette } from '@react-three/postprocessing';

    // --- Constants ---
    const COUNT = 2000;
    const SHAPES = {
      SCATTERED: 'SCATTERED',
      TREE: 'TREE',
      HEART: 'HEART'
    };
    
    // --- Helper Functions ---
    const randomRange = (min, max) => Math.random() * (max - min) + min;

    // --- Components ---

    // 1. Loading Screen
    const Loader = () => {
      return (
        <Html center>
          <div className="text-yellow-200 font-serif text-xl tracking-widest loading-text whitespace-nowrap">
            Loading Christmas Magic...
          </div>
        </Html>
      );
    };

    // 2. Magic Particles (The Tree/Heart Body)
    const MagicParticles = ({ shape }) => {
      const meshRef = useRef();
      const { viewport } = useThree();
      
      const dummy = useMemo(() => new THREE.Object3D(), []);
      
      const particles = useMemo(() => {
        const temp = [];
        // Tree Points (Spiral Cone)
        const treePoints = [];
        for (let i = 0; i < COUNT; i++) {
          const y = randomRange(-4, 4);
          const radius = (4 - y) * 0.4;
          const angle = y * 5 + Math.random() * Math.PI * 2;
          treePoints.push(new THREE.Vector3(Math.cos(angle) * radius, y, Math.sin(angle) * radius));
        }

        // Heart Points
        const heartPoints = [];
        for (let i = 0; i < COUNT; i++) {
          const t = Math.random() * Math.PI * 2;
          const x = 16 * Math.pow(Math.sin(t), 3);
          const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
          const scale = 0.15;
          heartPoints.push(new THREE.Vector3(x * scale, (y * scale) + 1, randomRange(-0.5, 0.5)));
        }

        // Scattered Points (Cloud)
        const scatteredPoints = [];
        for (let i = 0; i < COUNT; i++) {
          scatteredPoints.push(new THREE.Vector3(randomRange(-8, 8), randomRange(-5, 8), randomRange(-5, 5)));
        }

        for (let i = 0; i < COUNT; i++) {
          temp.push({
            tree: treePoints[i],
            heart: heartPoints[i],
            scattered: scatteredPoints[i],
            current: scatteredPoints[i].clone(), // Start scattered
            speed: randomRange(0.02, 0.05),
            offset: Math.random() * 100
          });
        }
        return temp;
      }, []);

      useFrame((state) => {
        if (!meshRef.current) return;
        
        const time = state.clock.getElapsedTime();

        particles.forEach((particle, i) => {
          let target;
          if (shape === SHAPES.TREE) target = particle.tree;
          else if (shape === SHAPES.HEART) target = particle.heart;
          else target = particle.scattered;

          // Morphing
          particle.current.lerp(target, 0.03);

          // Breathing/Floating animation
          const breathe = Math.sin(time * 2 + particle.offset) * 0.05;
          
          dummy.position.set(
            particle.current.x,
            particle.current.y + breathe,
            particle.current.z
          );
          
          const scale = (Math.sin(time * 3 + particle.offset) * 0.2 + 0.8) * 0.15;
          dummy.scale.set(scale, scale, scale);
          
          dummy.rotation.set(time * 0.2, time * 0.1, 0);
          
          dummy.updateMatrix();
          meshRef.current.setMatrixAt(i, dummy.matrix);
        });
        
        meshRef.current.instanceMatrix.needsUpdate = true;
      });

      return (
        <instancedMesh ref={meshRef} args={[null, null, COUNT]}>
          <dodecahedronGeometry args={[0.2, 0]} />
          {/* Silver-Green Shimmer Material (Dimmed to 0.15) */}
          <meshStandardMaterial 
            color="#2E8B57"        // SeaGreen
            emissive="#B0E0E6"     // PowderBlue
            emissiveIntensity={0.15} // Dimmed to 0.15 as requested
            roughness={0.6}        
            metalness={0.4}        
            toneMapped={false}
          />
        </instancedMesh>
      );
    };

    // 3. Planets (Scattered Mode Decoration)
    const PLANET_FACTS = [
      "1. 把你体内的DNA搓成一条线的话，它能延伸100亿英里，比地球到冥王星的距离还远。所以光靠你自己就足够离开太阳系了。",
      "2. 一朵云有多轻呢？大约五十万公斤。",
      "3. 如果我们能尝到的话，银河系中心尝起来大概会像覆盆子和朗姆酒的味道。",
      "4. 每个人的体内，都可能拥有来自超新星爆发产生的重元素原子。你我皆是星尘。",
      "5. 火星上的日落是蓝色的。",
      "6. 洛希极限是指当天体越过临界距离时，较小天体被潮汐力撕裂成碎片，用一次粉身碎骨换一个永恒的拥抱。"
    ];

    const Planets = ({ setActiveFact }) => {
      // Fixed positions for even distribution (Top, Bottom, Left, Right, Front, Back quadrants)
      const planetsData = useMemo(() => [
        { pos: [0, 6, 0], color: '#FFD700', size: 0.35, id: 0 },   // Top Gold
        { pos: [0, -6, 0], color: '#4169E1', size: 0.4, id: 1 },   // Bottom Blue
        { pos: [-7, 0, 2], color: '#FF69B4', size: 0.3, id: 2 },   // Left Pink
        { pos: [7, 0, -2], color: '#00FA9A', size: 0.35, id: 3 },  // Right Green
        { pos: [2, 2, 6], color: '#FFA500', size: 0.25, id: 4 },   // Front Orange
        { pos: [-2, -2, -6], color: '#9370DB', size: 0.3, id: 5 }, // Back Purple
      ], []);

      return (
        <group>
          {planetsData.map((data, index) => (
            <Float key={index} speed={1.5} rotationIntensity={0.5} floatIntensity={1}>
              <mesh 
                position={data.pos} 
                onClick={(e) => { e.stopPropagation(); setActiveFact(PLANET_FACTS[data.id]); }}
                onPointerOver={() => document.body.style.cursor = 'pointer'}
                onPointerOut={() => document.body.style.cursor = 'auto'}
              >
                <sphereGeometry args={[data.size, 32, 32]} />
                <meshStandardMaterial 
                  color={data.color} 
                  emissive={data.color} 
                  emissiveIntensity={2.0} 
                  toneMapped={false}
                />
              </mesh>
            </Float>
          ))}
        </group>
      );
    };

    // 4. Decorations (Text & Topper)
    const Decorations = ({ shape }) => {
      // Use jsdelivr for reliable loading
      const fontUrl = "https://cdn.jsdelivr.net/npm/three/examples/fonts/helvetiker_regular.typeface.json";
      
      const letters = useMemo(() => {
        // Tree: "MERRY CHRISTMAS AND HAPPY NEW YEAR"
        const treePhrase = "MERRY CHRISTMAS AND HAPPY NEW YEAR".split("").filter(c => c !== " ");
        
        // Heart: "THROUGH ALL THE PAIN YOU STILL SHINE"
        const heartPhrase = "THROUGH ALL THE PAIN YOU STILL SHINE".split("").filter(c => c !== " ");

        return treePhrase.map((char, i) => {
          // Spiral positions for Tree
          const t = i / treePhrase.length;
          const y = 3.5 - (t * 7); 
          const r = (4 - y) * 0.45 + 0.5;
          const angle = t * Math.PI * 6;
          
          // Heart curve positions
          // We map the heart phrase length to 0..2PI
          const tHeart = (i / heartPhrase.length) * Math.PI * 2;
          // Standard heart formula
          const hx = 16 * Math.pow(Math.sin(tHeart), 3);
          const hy = 13 * Math.cos(tHeart) - 5 * Math.cos(2*tHeart) - 2 * Math.cos(3*tHeart) - Math.cos(4*tHeart);
          // Scale it slightly larger than the particle heart
          const scale = 0.18; 

          return {
            char: char,
            heartChar: heartPhrase[i % heartPhrase.length], // Fallback if lengths differ
            treePos: [Math.cos(angle) * r, y, Math.sin(angle) * r],
            heartPos: [hx * scale, (hy * scale) + 1, 0.5], // Slight Z offset
            color: Math.random() > 0.5 ? "#FFF8DC" : "#E6E6FA", // PaleGold or PaleSilver
            rot: [0, -angle, 0]
          };
        });
      }, []);

      return (
        <group>
          {/* Tree Topper: Sun */}
          {shape === SHAPES.TREE && (
            <Float speed={2} rotationIntensity={0.5} floatIntensity={0.5}>
              <mesh position={[0, 4.2, 0]}>
                <sphereGeometry args={[0.3, 32, 32]} />
                <meshStandardMaterial 
                  color="#FFD700" 
                  emissive="#FFA500" 
                  emissiveIntensity={3} 
                  toneMapped={false} 
                />
              </mesh>
            </Float>
          )}

          {/* Floating Letters */}
          {letters.map((item, i) => {
             // Only show decorations in TREE or HEART mode
             if (shape === SHAPES.SCATTERED) return null;

             const isTree = shape === SHAPES.TREE;
             const pos = isTree ? item.treePos : item.heartPos;
             const rot = isTree ? item.rot : [0, 0, 0];
             const charToRender = isTree ? item.char : item.heartChar;
             const color = isTree ? item.color : "#FFFFE0"; // Pale Yellow for Heart

             return (
              <Float key={i} speed={2} rotationIntensity={0.2} floatIntensity={0.2}>
                <Center position={pos} rotation={rot}>
                  <Text3D
                    font={fontUrl}
                    size={isTree ? 0.25 : 0.15} // Smaller text for heart
                    height={0.05}
                    curveSegments={12}
                    bevelEnabled
                    bevelThickness={0.01}
                    bevelSize={0.01}
                    bevelOffset={0}
                    bevelSegments={5}
                  >
                    {charToRender}
                    <meshStandardMaterial color={color} emissive={color} emissiveIntensity={0.8} toneMapped={false} />
                  </Text3D>
                </Center>
              </Float>
             );
          })}
        </group>
      );
    };

    // 5. Meteor Shower (Full Screen)
    const Meteors = ({ active }) => {
      const meshRef = useRef();
      // 800 meteors filling the screen (wide range)
      const count = 800; 
      const dummy = useMemo(() => new THREE.Object3D(), []);
      
      const meteors = useMemo(() => {
        return new Array(count).fill(0).map(() => ({
          x: randomRange(-80, 80), // Very Wide X range (Screen width coverage)
          y: randomRange(30, 100), // Start high up
          z: randomRange(-40, 30), // Depth range (behind and in front of tree)
          speed: randomRange(0.8, 2.5),
          len: randomRange(3, 8)
        }));
      }, []);

      useFrame(() => {
        if (!active || !meshRef.current) return;
        
        meteors.forEach((m, i) => {
          m.y -= m.speed;
          m.x -= m.speed * 0.5; // Diagonal movement
          
          if (m.y < -30) {
            // Reset to top
            m.y = randomRange(30, 100);
            m.x = randomRange(-80, 80);
          }
          
          dummy.position.set(m.x, m.y, m.z);
          dummy.rotation.set(0, 0, Math.PI / 4);
          dummy.scale.set(0.1, m.len, 0.1);
          dummy.updateMatrix();
          meshRef.current.setMatrixAt(i, dummy.matrix);
        });
        meshRef.current.instanceMatrix.needsUpdate = true;
      });

      if (!active) return null;

      return (
        <instancedMesh ref={meshRef} args={[null, null, count]}>
          <boxGeometry args={[1, 1, 1]} />
          <meshBasicMaterial color="#FFFFFF" transparent opacity={0.8} />
        </instancedMesh>
      );
    };

    // --- Main App Component ---
    const App = () => {
      const [shape, setShape] = useState(SHAPES.TREE);
      const [wishing, setWishing] = useState(false);
      const [countdown, setCountdown] = useState(null);
      const [activeFact, setActiveFact] = useState(null);
      const [sceneVisible, setSceneVisible] = useState(true);

      // Music Player
      useEffect(() => {
        const audio = document.getElementById('bg-music');
        audio.volume = 0.5;
        const playAudio = () => {
          audio.play().catch(e => console.log("Audio play failed (interaction needed):", e));
          window.removeEventListener('click', playAudio);
        };
        window.addEventListener('click', playAudio);
        return () => window.removeEventListener('click', playAudio);
      }, []);

      // Music Upload Handler
      const handleMusicUpload = (e) => {
        const file = e.target.files[0];
        if (file) {
          const url = URL.createObjectURL(file);
          const audio = document.getElementById('bg-music');
          audio.src = url;
          audio.play();
        }
      };

      // Make a Wish Logic
      const handleWish = () => {
        // 1. Hide Scene
        setSceneVisible(false);
        setShape(SHAPES.SCATTERED); 
        
        // 2. Start Countdown
        setCountdown(10);
      };

      // Countdown Effect
      useEffect(() => {
        if (countdown === null) return;
        
        if (countdown > 0) {
          const timer = setTimeout(() => setCountdown(c => c - 1), 1000);
          return () => clearTimeout(timer);
        } else {
          // Countdown finished -> Start Meteor Shower
          setWishing(true);
          const fx = document.getElementById('meteor-fx');
          fx.volume = 1.0;
          fx.currentTime = 0;
          fx.play();
          
          // Wait 10s then Restore
          const restoreTimer = setTimeout(() => {
            setWishing(false);
            setCountdown(null);
            setSceneVisible(true);
            setShape(SHAPES.TREE); // Go back to tree
          }, 10000);
          
          return () => clearTimeout(restoreTimer);
        }
      }, [countdown]);

      return (
        <>
          <Canvas 
            camera={{ position: [0, 0, 12], fov: 45 }} 
            gl={{ toneMappingExposure: 2.5 }}
          >
            <color attach="background" args={['#000010']} />
            
            {/* Ambient Elements (Always Visible) */}
            <Stars radius={100} depth={50} count={5000} factor={4} saturation={0} fade speed={1} />
            <Sparkles count={500} scale={20} size={2} speed={0.4} opacity={0.5} color="#FFD700" />
            <ambientLight intensity={0.8} />
            <pointLight position={[10, 10, 10]} intensity={2.0} />
            <pointLight position={[-10, -10, -10]} intensity={1.0} />

            {/* Conditionally Visible Scene */}
            <Suspense fallback={<Loader />}>
              <group visible={sceneVisible}>
                <MagicParticles shape={shape} />
                <Decorations shape={shape} />
                {shape === SHAPES.SCATTERED && <Planets setActiveFact={setActiveFact} />}
              </group>
            </Suspense>

            {/* Meteors (Visible during wishing phase) */}
            <Meteors active={wishing} />

            {/* Post Processing */}
            <EffectComposer>
              <Bloom luminanceThreshold={0.5} luminanceSmoothing={0.9} intensity={1.5} />
              <Vignette eskil={false} offset={0.1} darkness={0.5} />
            </EffectComposer>
            
            <OrbitControls 
              enableZoom={true} 
              enablePan={false} 
              minPolarAngle={Math.PI / 4} 
              maxPolarAngle={Math.PI / 1.5}
            />
          </Canvas>

          {/* --- UI Overlays --- */}

          {/* Top Left Title */}
          <div className="absolute top-6 left-6 z-10 pointer-events-none">
            <h1 className="text-3xl font-serif text-transparent bg-clip-text bg-gradient-to-r from-yellow-200 to-yellow-500 drop-shadow-[0_0_10px_rgba(255,215,0,0.5)]">
              Merry Christmas<br/>& Happy New Year!
            </h1>
          </div>

          {/* Fact Popup */}
          {activeFact && (
            <div className="absolute inset-0 flex items-center justify-center z-50 bg-black/60 backdrop-blur-sm" onClick={() => setActiveFact(null)}>
              <div className="bg-slate-900/90 border border-slate-700 p-8 rounded-2xl max-w-md text-center shadow-[0_0_50px_rgba(100,200,255,0.2)] transform transition-all scale-100 hover:scale-105">
                <p className="text-blue-100 text-lg leading-relaxed font-light">{activeFact}</p>
                <p className="text-slate-500 text-sm mt-4">(Click anywhere to close)</p>
              </div>
            </div>
          )}

          {/* Countdown Overlay */}
          {countdown !== null && countdown > 0 && (
            <div className="absolute inset-0 flex items-center justify-center z-50 pointer-events-none">
              <div className="text-9xl font-bold text-yellow-100 drop-shadow-[0_0_50px_rgba(255,215,0,1)] countdown-text">
                {countdown}
              </div>
            </div>
          )}

          {/* Wish Message Overlay */}
          {wishing && (
            <div className="absolute inset-0 flex flex-col items-center justify-center z-50 pointer-events-none p-4">
              <h1 className="text-5xl md:text-7xl font-bold text-center text-transparent bg-clip-text bg-gradient-to-r from-yellow-200 via-white to-yellow-200 drop-shadow-[0_0_30px_rgba(253,224,71,0.6)] mb-6 font-serif animate-pulse">
                Your wish will come true!!!!
              </h1>
              {/* Small subtitle text */}
              <p className="text-sm text-white/80 font-light tracking-[0.2em] drop-shadow-[0_0_10px_rgba(255,255,255,0.3)]">
                我会和你一起实现
              </p>
            </div>
          )}

          {/* Controls (Hidden during wish) */}
          {sceneVisible && (
            <div className="absolute bottom-0 left-0 right-0 p-6 flex flex-col items-center justify-end z-40 pointer-events-none">
              
              {/* Shape Controls */}
              <div className="flex gap-4 pointer-events-auto mb-4 bg-black/20 backdrop-blur-md p-3 rounded-full border border-white/10">
                <button 
                  onClick={() => setShape(SHAPES.TREE)}
                  className={`px-6 py-2 rounded-full transition-all duration-300 font-light tracking-widest ${shape === SHAPES.TREE ? 'bg-emerald-500/80 text-white shadow-[0_0_20px_rgba(16,185,129,0.5)]' : 'bg-white/5 text-emerald-200 hover:bg-white/10'}`}
                >
                  TREE
                </button>
                <button 
                  onClick={() => setShape(SHAPES.HEART)}
                  className={`px-6 py-2 rounded-full transition-all duration-300 font-light tracking-widest ${shape === SHAPES.HEART ? 'bg-pink-500/80 text-white shadow-[0_0_20px_rgba(236,72,153,0.5)]' : 'bg-white/5 text-pink-200 hover:bg-white/10'}`}
                >
                  HEART
                </button>
                <button 
                  onClick={() => setShape(SHAPES.SCATTERED)}
                  className={`px-6 py-2 rounded-full transition-all duration-300 font-light tracking-widest ${shape === SHAPES.SCATTERED ? 'bg-blue-500/80 text-white shadow-[0_0_20px_rgba(59,130,246,0.5)]' : 'bg-white/5 text-blue-200 hover:bg-white/10'}`}
                >
                  SCATTER
                </button>
              </div>

              {/* Music Upload */}
              <div className="pointer-events-auto">
                <label className="cursor-pointer flex items-center gap-2 text-white/70 hover:text-white transition-colors bg-white/5 px-4 py-1.5 rounded-full border border-white/10 hover:bg-white/10 text-sm">
                  <span>♫ Upload Music</span>
                  <input type="file" accept="audio/*" className="hidden" onChange={handleMusicUpload} />
                </label>
              </div>
            </div>
          )}

          {/* Make A Wish Button (Bottom Right) */}
          {sceneVisible && (
            <div className="absolute bottom-6 right-6 z-50 pointer-events-auto">
               <button 
                  onClick={handleWish}
                  className="px-6 py-3 rounded-full bg-gradient-to-r from-amber-200 to-yellow-400 text-amber-900 font-bold tracking-wider shadow-[0_0_25px_rgba(251,191,36,0.6)] hover:scale-110 hover:shadow-[0_0_40px_rgba(251,191,36,0.8)] transition-all duration-500 ease-out"
                >
                  ✨ MAKE A WISH
                </button>
            </div>
          )}

        </>
      );
    };

    const root = createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
