
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Merry Christmas & Happy New Year</title>
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- Import Map: Modern Stack (Three 0.160.0) -->
  <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
        "three": "https://esm.sh/three@0.160.0",
        "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.16?external=react,react-dom,three",
        "@react-three/drei": "https://esm.sh/@react-three/drei@9.99.0?external=react,react-dom,three,@react-three/fiber",
        "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0?external=react,react-dom,three,@react-three/fiber",
        "postprocessing": "https://esm.sh/postprocessing@6.34.1?external=three",
        "uuid": "https://esm.sh/uuid@9.0.1"
      }
    }
  </script>

  <!-- Babel -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #000010; }
    #root { width: 100%; height: 100%; }
    
    @keyframes pulse-glow {
      0%, 100% { text-shadow: 0 0 20px #FFD700, 0 0 40px #FFA500; transform: scale(1); }
      50% { text-shadow: 0 0 40px #FFD700, 0 0 80px #FFA500; transform: scale(1.1); }
    }
    .countdown-text {
      font-family: 'Times New Roman', serif;
      animation: pulse-glow 1s infinite ease-in-out;
    }
    .loading-text {
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    /* Hide scrollbar for planet facts overlay */
    .no-scrollbar::-webkit-scrollbar {
      display: none;
    }
    .no-scrollbar {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- Background Music Audio Element -->
  <audio id="bg-music" loop>
    <source src="https://cdn.pixabay.com/download/audio/2022/11/22/audio_febc508520.mp3?filename=christmas-magic-127058.mp3" type="audio/mpeg">
  </audio>

  <!-- Meteor Sound Effect -->
  <audio id="meteor-fx">
    <source src="https://cdn.pixabay.com/download/audio/2022/03/24/audio_338a906253.mp3?filename=magic-chime-02-6014.mp3" type="audio/mpeg">
  </audio>

  <script type="text/babel" data-type="module">
    import React, { useState, useRef, useMemo, useEffect, Suspense } from 'react';
    import { createRoot } from 'react-dom/client';
    import * as THREE from 'three';
    import { Canvas, useFrame, useThree } from '@react-three/fiber';
    import { OrbitControls, PerspectiveCamera, Stars, Float, Text3D, Center, Sparkles, Html } from '@react-three/drei';
    import { EffectComposer, Bloom, Vignette } from '@react-three/postprocessing';

    // --- Constants ---
    const COUNT = 2000;
    const SHAPES = {
      SCATTERED: 'SCATTERED',
      TREE: 'TREE',
      HEART: 'HEART'
    };
    
    // --- Helper Functions ---
    const randomRange = (min, max) => Math.random() * (max - min) + min;

    // --- Components ---

    // 1. Loading Screen
    const Loader = () => {
      return (
        <Html center>
          <div className="text-yellow-200 font-serif text-xl tracking-widest loading-text whitespace-nowrap">
            Loading Christmas Magic...
          </div>
        </Html>
      );
    };

    // 2. Magic Particles (The Tree/Heart Body)
    const MagicParticles = ({ shape }) => {
      const meshRef = useRef();
      const { viewport } = useThree();
      
      const dummy = useMemo(() => new THREE.Object3D(), []);
      
      const particles = useMemo(() => {
        const temp = [];
        // Tree Points (Spiral Cone)
        const treePoints = [];
        for (let i = 0; i < COUNT; i++) {
          const y = randomRange(-4, 4);
          const radius = (4 - y) * 0.4;
          const angle = y * 5 + Math.random() * Math.PI * 2;
          treePoints.push(new THREE.Vector3(Math.cos(angle) * radius, y, Math.sin(angle) * radius));
        }

        // Heart Points (Fully Filled Volume)
        const heartPoints = [];
        let attempts = 0;
        // Increase loop limit to ensure we find enough points for a dense volume
        while(heartPoints.length < COUNT && attempts < 100000) {
          attempts++;
          // Bounding box for heart
          const x = randomRange(-1.5, 1.5);
          const y = randomRange(-1.5, 2.0); // Shifted Y for centering
          const z = randomRange(-0.8, 0.8);
          
          // Scaling for visual size
          const scale = 1.8; 
          const x0 = x * scale;
          const y0 = y * scale;
          const z0 = z * scale;

          // Heart Volume Inequality: (x^2 + 9/4y^2 + z^2 - 1)^3 - x^2z^3 - 9/80y^2z^3 <= 0
          // Adjusted X/Y/Z inputs for the formula logic
          // Normalize inputs to fit roughly unit heart size for calculation
          const nx = x;
          const ny = y - 0.5; // shift down slightly
          const nz = z;
          
          const a = nx*nx + (9/4)*ny*ny + nz*nz - 1;
          const term2 = nx*nx * nz*nz*nz;
          const term3 = (9/80)*ny*ny * nz*nz*nz;

          if (a*a*a - term2 - term3 <= 0) {
             heartPoints.push(new THREE.Vector3(x0, y0, z0));
          }
        }
        // If we didn't fill it (rare), fill randomly inside a sphere as fallback
        while(heartPoints.length < COUNT) {
             const r = 1.5 * Math.cbrt(Math.random());
             const theta = Math.random() * 2 * Math.PI;
             const phi = Math.acos(2 * Math.random() - 1);
             heartPoints.push(new THREE.Vector3(
                 r * Math.sin(phi) * Math.cos(theta),
                 r * Math.sin(phi) * Math.sin(theta),
                 r * Math.cos(phi)
             ));
        }

        // Scattered Points (Cloud)
        const scatteredPoints = [];
        for (let i = 0; i < COUNT; i++) {
          scatteredPoints.push(new THREE.Vector3(randomRange(-8, 8), randomRange(-5, 8), randomRange(-5, 5)));
        }

        for (let i = 0; i < COUNT; i++) {
          temp.push({
            tree: treePoints[i],
            heart: heartPoints[i],
            scattered: scatteredPoints[i],
            current: scatteredPoints[i].clone(), // Start scattered
            speed: randomRange(0.02, 0.05),
            offset: Math.random() * 100
          });
        }
        return temp;
      }, []);

      useFrame((state) => {
        if (!meshRef.current) return;
        
        const time = state.clock.getElapsedTime();

        particles.forEach((particle, i) => {
          let target;
          if (shape === SHAPES.TREE) target = particle.tree;
          else if (shape === SHAPES.HEART) target = particle.heart;
          else target = particle.scattered;

          // Morphing
          particle.current.lerp(target, 0.03);

          // Breathing/Floating animation
          const breathe = Math.sin(time * 2 + particle.offset) * 0.05;
          
          dummy.position.set(
            particle.current.x,
            particle.current.y + breathe,
            particle.current.z
          );
          
          const scale = (Math.sin(time * 3 + particle.offset) * 0.2 + 0.8) * 0.15;
          dummy.scale.set(scale, scale, scale);
          
          dummy.rotation.set(time * 0.2, time * 0.1, 0);
          
          dummy.updateMatrix();
          meshRef.current.setMatrixAt(i, dummy.matrix);
        });
        
        meshRef.current.instanceMatrix.needsUpdate = true;
      });

      return (
        <instancedMesh ref={meshRef} args={[null, null, COUNT]}>
          <dodecahedronGeometry args={[0.2, 0]} />
          {/* Silver-Green Shimmer Material (Dimmed to 0.15) */}
          <meshStandardMaterial 
            color="#2E8B57"        // SeaGreen
            emissive="#B0E0E6"     // PowderBlue
            emissiveIntensity={0.15} // Dimmed to 0.15 as requested
            roughness={0.6}        
            metalness={0.4}        
            toneMapped={false}
          />
        </instancedMesh>
      );
    };

    // 3. Planets (Scattered Mode Decoration)
    const PLANET_FACTS = [
      "1. 把你体内的DNA搓成一条线的话，它能延伸100亿英里，比地球到冥王星的距离还远。所以光靠你自己就足够离开太阳系了。",
      "2. 一朵云有多轻呢？大约五十万公斤。",
      "3. 如果我们能尝到的话，银河系中心尝起来大概会像覆盆子和朗姆酒的味道。",
      "4. 每个人的体内，都可能拥有来自超新星爆发产生的重元素原子。你我皆是星尘。",
      "5. 火星上的日落是蓝色的。",
      "6. 洛希极限是指当天体越过临界距离时，较小天体被潮汐力撕裂成碎片，用一次粉身碎骨换一个永恒的拥抱。"
    ];

    const Planets = ({ setActiveFact }) => {
      // Fixed positions for even distribution
      // Reduced size by ~1/3 (approx 0.1 to 0.13)
      const planetsData = useMemo(() => [
        { pos: [0, 6, 0], color: '#FFD700', size: 0.12, id: 0 },   
        { pos: [0, -6, 0], color: '#4169E1', size: 0.13, id: 1 },   
        { pos: [-7, 0, 2], color: '#FF69B4', size: 0.1, id: 2 },   
        { pos: [7, 0, -2], color: '#00FA9A', size: 0.12, id: 3 },  
        { pos: [2, 2, 6], color: '#FFA500', size: 0.09, id: 4 },   
        { pos: [-2, -2, -6], color: '#9370DB', size: 0.1, id: 5 }, 
      ], []);

      return (
        <group>
          {planetsData.map((data, index) => (
            <Float key={index} speed={1.5} rotationIntensity={0.5} floatIntensity={1}>
              <mesh 
                position={data.pos} 
                onClick={(e) => { e.stopPropagation(); setActiveFact(PLANET_FACTS[data.id]); }}
                onPointerOver={() => document.body.style.cursor = 'pointer'}
                onPointerOut={() => document.body.style.cursor = 'auto'}
              >
                <sphereGeometry args={[data.size, 32, 32]} />
                {/* Increased emissive intensity to 4.0 for brighter glow on smaller objects */}
                <meshStandardMaterial 
                  color={data.color} 
                  emissive={data.color} 
                  emissiveIntensity={4.0} 
                  toneMapped={false}
                />
              </mesh>
            </Float>
          ))}
        </group>
      );
    };

    // 4. Decorations (Text & Topper)
    const Decorations = ({ shape }) => {
      const fontUrl = "https://cdn.jsdelivr.net/npm/three/examples/fonts/helvetiker_regular.typeface.json";
      
      const letters = useMemo(() => {
        // Tree: "MERRY CHRISTMAS AND HAPPY NEW YEAR"
        const treePhrase = "MERRY CHRISTMAS AND HAPPY NEW YEAR".split("").filter(c => c !== " ");
        
        // Heart: "THROUGH ALL THE PAIN YOU STILL SHINE"
        const heartPhrase = "THROUGH ALL THE PAIN YOU STILL SHINE".split("").filter(c => c !== " ");

        return treePhrase.map((char, i) => {
          // Spiral positions for Tree
          const t = i / treePhrase.length;
          const y = 3.5 - (t * 7); 
          const r = (4 - y) * 0.45 + 0.5;
          const angle = t * Math.PI * 6;
          
          // Heart curve positions for text decoration (Outer rim)
          // Keep text on the "rim" so it's readable, while the green stars fill the volume
          const tHeart = (i / heartPhrase.length) * Math.PI * 2;
          // Parametric heart curve for outline
          const hx = 16 * Math.pow(Math.sin(tHeart), 3);
          const hy = 13 * Math.cos(tHeart) - 5 * Math.cos(2*tHeart) - 2 * Math.cos(3*tHeart) - Math.cos(4*tHeart);
          const scale = 0.22; 

          return {
            char: char,
            heartChar: heartPhrase[i % heartPhrase.length], // Fallback
            treePos: [Math.cos(angle) * r, y, Math.sin(angle) * r],
            heartPos: [hx * scale, (hy * scale) + 1, 1.2], // Slightly in front of the filled volume
            color: Math.random() > 0.5 ? "#FFF8DC" : "#E6E6FA",
            rot: [0, -angle, 0]
          };
        });
      }, []);

      return (
        <group>
          {/* Tree Topper: Sun */}
          {shape === SHAPES.TREE && (
            <Float speed={2} rotationIntensity={0.5} floatIntensity={0.5}>
              <mesh position={[0, 4.2, 0]}>
                <sphereGeometry args={[0.3, 32, 32]} />
                <meshStandardMaterial 
                  color="#FFD700" 
                  emissive="#FFA500" 
                  emissiveIntensity={3} 
                  toneMapped={false} 
                />
              </mesh>
            </Float>
          )}

          {/* Floating Letters */}
          {letters.map((item, i) => {
             if (shape === SHAPES.SCATTERED) return null;

             const isTree = shape === SHAPES.TREE;
             const pos = isTree ? item.treePos : item.heartPos;
             const rot = isTree ? item.rot : [0, 0, 0];
             const charToRender = isTree ? item.char : item.heartChar;
             const color = isTree ? item.color : "#FFFFE0"; 

             return (
              <Float key={i} speed={2} rotationIntensity={0.2} floatIntensity={0.2}>
                <Center position={pos} rotation={rot}>
                  <Text3D
                    font={fontUrl}
                    size={isTree ? 0.15 : 0.1} // Reduced text size: 0.15 for Tree, 0.1 for Heart
                    height={0.02}
                    curveSegments={12}
                    bevelEnabled
                    bevelThickness={0.01}
                    bevelSize={0.002}
                    bevelOffset={0}
                    bevelSegments={3}
                  >
                    {charToRender}
                    <meshStandardMaterial color={color} emissive={color} emissiveIntensity={0.8} toneMapped={false} />
                  </Text3D>
                </Center>
              </Float>
             );
          })}
        </group>
      );
    };

    // 5. Meteor Shower (Full Screen)
    const Meteors = ({ active }) => {
      const meshRef = useRef();
      const count = 800; // Increased count
      const dummy = useMemo(() => new THREE.Object3D(), []);
      
      const meteors = useMemo(() => {
        return new Array(count).fill(0).map(() => ({
          x: randomRange(-80, 80), // Full Screen X
          y: randomRange(30, 100), 
          z: randomRange(-40, 30), // Full Depth Z
          speed: randomRange(0.8, 2.5),
          len: randomRange(3, 8)
        }));
      }, []);

      useFrame(() => {
        if (!active || !meshRef.current) return;
        
        meteors.forEach((m, i) => {
          m.y -= m.speed;
          m.x -= m.speed * 0.5;
          
          if (m.y < -30) {
            m.y = randomRange(30, 100);
            m.x = randomRange(-80, 80);
          }
          
          dummy.position.set(m.x, m.y, m.z);
          dummy.rotation.set(0, 0, Math.PI / 4);
          dummy.scale.set(0.1, m.len, 0.1);
          dummy.updateMatrix();
          meshRef.current.setMatrixAt(i, dummy.matrix);
        });
        meshRef.current.instanceMatrix.needsUpdate = true;
      });

      if (!active) return null;

      return (
        <instancedMesh ref={meshRef} args={[null, null, count]}>
          <boxGeometry args={[1, 1, 1]} />
          <meshBasicMaterial color="#FFFFFF" transparent opacity={0.8} />
        </instancedMesh>
      );
    };

    // --- Main App Component ---
    const App = () => {
      const [shape, setShape] = useState(SHAPES.TREE);
      const [wishing, setWishing] = useState(false);
      const [countdown, setCountdown] = useState(null);
      const [activeFact, setActiveFact] = useState(null);
      const [sceneVisible, setSceneVisible] = useState(true);

      // Music Player Setup
      useEffect(() => {
        const audio = document.getElementById('bg-music');
        audio.volume = 0.5;
        const playAudio = () => {
          audio.play().catch(e => console.log("Audio play failed (interaction needed):", e));
          window.removeEventListener('click', playAudio);
        };
        window.addEventListener('click', playAudio);
        return () => window.removeEventListener('click', playAudio);
      }, []);

      const handleMusicUpload = (e) => {
        const file = e.target.files[0];
        if (file) {
          const url = URL.createObjectURL(file);
          const audio = document.getElementById('bg-music');
          audio.src = url;
          audio.play();
        }
      };

      const handleWish = () => {
        setSceneVisible(false);
        setShape(SHAPES.SCATTERED); 
        setCountdown(10);
      };

      useEffect(() => {
        if (countdown === null) return;
        
        if (countdown > 0) {
          const timer = setTimeout(() => setCountdown(c => c - 1), 1000);
          return () => clearTimeout(timer);
        } else {
          // Countdown Finished -> Meteor Shower
          setWishing(true);
          const fx = document.getElementById('meteor-fx');
          fx.volume = 1.0;
          fx.currentTime = 0;
          fx.play();
          
          const restoreTimer = setTimeout(() => {
            setWishing(false);
            setCountdown(null);
            setSceneVisible(true);
            setShape(SHAPES.TREE);
          }, 10000);
          
          return () => clearTimeout(restoreTimer);
        }
      }, [countdown]);

      return (
        <>
          <Canvas camera={{ position: [0, 0, 15], fov: 60 }} dpr={[1, 2]}>
            <Suspense fallback={<Loader />}>
              <color attach="background" args={['#000010']} />
              <Stars radius={100} depth={50} count={5000} factor={4} saturation={0} fade speed={1} />
              
              <ambientLight intensity={0.8} />
              <pointLight position={[10, 10, 10]} intensity={2.0} />
              <pointLight position={[-10, -10, -10]} intensity={1.0} />

              <group visible={sceneVisible}>
                <MagicParticles shape={shape} />
                <Decorations shape={shape} />
                {shape === SHAPES.SCATTERED && <Planets setActiveFact={setActiveFact} />}
              </group>

              {/* Meteors separate so they show when scene is hidden during wish */}
              <Meteors active={wishing} />

              <EffectComposer>
                <Bloom luminanceThreshold={0.5} luminanceSmoothing={0.9} height={300} intensity={1.5} />
                <Vignette eskil={false} offset={0.1} darkness={1.1} />
              </EffectComposer>
              
              <OrbitControls 
                enableZoom={true} 
                enablePan={false} 
                rotateSpeed={0.5} 
                minDistance={5} 
                maxDistance={30}
              />
            </Suspense>
          </Canvas>

          {/* Top Left Title */}
          <div className="absolute top-6 left-6 text-white z-10 pointer-events-none">
            <h1 className="text-2xl font-serif tracking-widest text-yellow-100 drop-shadow-[0_0_10px_rgba(255,215,0,0.5)]">
              Merry Christmas & Happy New Year!
            </h1>
          </div>

          {/* Bottom Right Controls (Make A Wish & Music) */}
          {sceneVisible && (
            <div className="absolute bottom-6 right-6 flex flex-col gap-4 z-20">
              {/* Music Upload Button */}
              <label className="bg-white/10 hover:bg-white/20 backdrop-blur-md border border-white/30 text-white px-6 py-2 rounded-full cursor-pointer transition-all text-sm text-center">
                ♫ Music
                <input type="file" accept="audio/*" onChange={handleMusicUpload} className="hidden" />
              </label>

              {/* Make a Wish Button */}
              <button 
                onClick={handleWish}
                className="bg-gradient-to-r from-yellow-200 to-amber-400 text-black font-serif px-8 py-3 rounded-full shadow-[0_0_20px_rgba(255,215,0,0.6)] hover:scale-105 transition-transform"
              >
                Make a Wish
              </button>
            </div>
          )}

          {/* Bottom Center Shape Controls (Only visible when scene is visible) */}
          {sceneVisible && (
            <div className="absolute bottom-6 left-1/2 -translate-x-1/2 flex gap-6 z-20">
              <button onClick={() => setShape(SHAPES.TREE)} className={`text-white/80 hover:text-white transition-colors ${shape === SHAPES.TREE ? 'font-bold text-yellow-200' : ''}`}>TREE</button>
              <button onClick={() => setShape(SHAPES.HEART)} className={`text-white/80 hover:text-white transition-colors ${shape === SHAPES.HEART ? 'font-bold text-pink-200' : ''}`}>HEART</button>
              <button onClick={() => setShape(SHAPES.SCATTERED)} className={`text-white/80 hover:text-white transition-colors ${shape === SHAPES.SCATTERED ? 'font-bold text-blue-200' : ''}`}>GALAXY</button>
            </div>
          )}

          {/* Countdown Overlay */}
          {countdown !== null && (
            <div className="absolute inset-0 flex items-center justify-center pointer-events-none z-50">
              <div className="text-[15rem] text-yellow-100 countdown-text drop-shadow-[0_0_50px_rgba(255,215,0,0.8)]">
                {countdown}
              </div>
            </div>
          )}

          {/* Wish Message Overlay */}
          {wishing && (
            <div className="absolute inset-0 flex flex-col items-center justify-center pointer-events-none z-50 bg-black/20">
              <h2 className="text-4xl md:text-6xl text-transparent bg-clip-text bg-gradient-to-r from-yellow-100 via-white to-yellow-100 font-serif drop-shadow-[0_0_30px_rgba(255,255,255,0.8)] animate-pulse mb-4">
                Your wish will come true!!!!
              </h2>
              {/* Small Elegant Subtitle */}
              <p className="text-sm text-white/80 font-light tracking-widest font-serif italic">
                我会和你一起实现
              </p>
            </div>
          )}

          {/* Planet Fact Overlay */}
          {activeFact && (
            <div className="absolute inset-0 flex items-center justify-center z-50 bg-black/60 backdrop-blur-sm" onClick={() => setActiveFact(null)}>
              <div className="bg-slate-900/90 border border-white/20 p-8 rounded-2xl max-w-lg mx-4 text-center shadow-[0_0_50px_rgba(100,200,255,0.2)]" onClick={e => e.stopPropagation()}>
                <p className="text-blue-100 text-lg leading-relaxed font-serif">
                  {activeFact}
                </p>
                <button 
                  onClick={() => setActiveFact(null)}
                  className="mt-6 text-sm text-white/50 hover:text-white transition-colors"
                >
                  Close
                </button>
              </div>
            </div>
          )}
        </>
      );
    };

    const root = createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
